/**
 * @page FAQS
 * 
 * @author Jesse Cureton
 *
 * @section WHY_DEFINES Why are there so many #defines?
 *
 * Enums exist for a reason in C, right? So why are things like {@link SYSTEM_STATES}, {@link SYSTEM_ERRORS}, etc. defines instead of enums?
 *
 * This is mostly due to consistency, but also because some of these things can't be properly represented as enums. Let's take the {@link ERRORS}
 * variable and its corresponding {@link SYSTEM_ERRORS} definition group as an example. ERRORS acts as a good ole-fashioned C bitfield without
 * actually implementing a technical C bitfield. (See @ref BITFIELDS for an explanation of why)
 *
 * We use the {@link SYSTEM_ERRORS} values to mark what system problem each bit being set in {@link ERRORS} corresponds to. This functionality
 * can't actually be replicated using an enum. Because of this we use defines for the system errors bitfield, and all of the other bitfields.
 * 
 * In another case, looking at {@link state} and {@link SYSTEM_STATES}, this functionality would actually be better served by an enum. However,
 * for consistency's sake we use defines for it as well. This is also true of {@link IO_EXPS} and several other types that seem well-suited to
 * enums. We can emulate the type safety that enums provide by proper documentation using defgroups and param/return tags in functions requiring
 * one of these values to be passed in.
 * 
 * TL/DR: If it seems like an enum could do it, it probably could. Use defines anyway, and document them well with param and return tags linking
 * to the original defgroup.
 *
 * @see @ref BITFIELDS
 *
 * @section BITFIELDS What the heck is a bitfield?
 * 
 * A bitfield is a way of using a datatype to store information in a binary format that may not correspond to an existing format. This can
 * be a bit abstract to grasp at first, so let's take a practical example and look at the {@link ERRORS} bitfield. Note that {@link ERRORS}
 * is a uint8_t, an unsigned 8-bit integer. Let's look at each bit in the variable.
 *
 * <code><pre>{@link ERRORS} = _ _ _ _ _ _ _ _
 *     Bit: 7 6 5 4 3 2 1 0</pre></code>
 *
 * Each bit corresponds to a value in {@link SYSTEM_ERRORS}. {@link TEMP_FAULT} denotes a temperature fault, and is defined as BIT6, which
 * is a compiler-level define for a 1 in bit 6 of an unsigned integer. That is:
 *
 * <code>TEMP_FAULT = BIT6 = 01000000</code>
 *
 * By using {@link BITWISE_OPS bitwise operations}, we can check if a certain bit (or set of bits) in a variable is set to a certain value.
 * This means we can check if the TEMP_FAULT bit in ERRORS is high, and if it is, that denotes that there is a temperature fault in the system
 * right now.
 *
 * @note An astute reader will read this and say "Hey! C implements bitfields, and I don't remember them looking like this!" Well, dear reader,
 * you are correct! We do not use a standard implementation of C bitfields because it is dependent on byte ordering in memory, which varies
 * across processor architectures. When we send data from one of our microcontrollers over CAN, it will be received by x86 processors running
 * the telem software, which reverse byte ordering from the MSP430.
 * <br><br>
 * By using standard unsigned integer types, and then hard defines to certain BITx values, we can ensure that our fields don't get messed up
 * in translation. BIT7 resolves to 1000000, which is ALWAYS equal to 128 in decimal for any unsigned integer type, on any platform. This means
 * regardless of x86 storing bits in memory in the opposite order, if the most significant bit of an unsigned 8-bit integer is set, it corresponds
 * with BIT7 being high on our processor here, and we can draw data from our bitfield.
 * <br><br>
 * The same logic applies to sending data we keep on the board to registers on other devices over SPI or another communication protocol. We 
 * always know what value is in what position, regardless of the actual memory implementation underlying it.
 *
 * @section BITWISE_OPS	How do bitwise operations work?
 * 
 * In C, you are surely familiar with your standard logical operators <code> && (AND)</code> and <code> || (OR)</code>. If you took a digital logic class in high school, or have taken discrete math or CpE2210 here on campus, feel free to proceed. If not,
 * give the Sparkfun link in the "See More" section a good read until you understand the concept of a logic AND and OR operation at the bit level.
 *
 * Equivalent operations to the logical operators exist to act upon individual bits. These are the "bitwise" operators <code> & </code> and <code> | </code>.
 * The bitwise operators perform a logic OR, AND, XOR, or other logic operation bit-by-bit on the left and right hand arguments to the operator.
 *
 * We can use these operations to evaluate statements involving single bits, like in our bitfields. Let's see an example:
 *
 * <code><pre>
 *       AND			 OR
 *     01010101       01010101
 *   & 11101011     | 11101011
 *     --------       --------
 *     01000001       11111111</pre></code>
 *
 * See that the AND operation result had a 1 where both bits in the two operands were 1, and 0's elsewhere. The OR operation has a 1 wherever
 * either operand had a 1 in that bit.
 *
 * If you think about it, you may see a way we could use the AND operation to tell if a bit was set. Let's look back at the description of {@link ERRORS}
 * in the {@ref BITFIELDS} section. Say we have errors defined as below, and TEMP_FAULT defined as BIT6 as always.
 *
 * <code><pre>    {@link ERRORS} = 01001000
 * TEMP_FAULT = 01000000</pre></code>
 * 
 * Let's AND these values together. The result is 01000000. This evaluates to <code>true</code>, so we now know that the TEMP_FAULT bit in ERRORS
 * was set, and therefore there was a temperature fault in the system. If the TEMP_FAULT bit in ERRORS weren't set, the AND would have returned
 * 00000000, and then evaluated to <code>false</code>.
 *
 * @note Remember, in C a value of <code>0</code> evaluates to <code>false</code>, and literally any other value evaluates to <code>true</code>.
 *
 * If we extend our thinking about bitwise operations to include assignment operations, we can now think in terms of setting, clearing, or toggling
 * a single bit in a value. These operations are <code>&=</code> and <code>|=</code>. They are AND-EQUALS and OR-EQUALS, respectively. We also have
 * one more bitwise operation that I haven't mentioned yet - the bitwise NOT, written <code>~</code>. The NOT operation inverts all bits in the 
 * operand it is applied to.
 *
 * If we want to set a bit we can think about the OR operation, where on a bit-by-bit basis ORing a value with 0 is an equivalency relation,
 * that is the output bit is the same as the input bit. ORing with a 1 will always result in a 1 in the output bit. The OR-EQUALS operation
 * can therefore be used to set a bit, since it stores the resulting value in the left-side operand. Take <code>val=01101001</code>, and <code>BIT7=10000000</code>.
 *
 * <code>val |= BIT7</code>
 *
 * This gives us <code>val=11101001</code> and suddenly we've successfully set BIT7 in val.
 *
 * Now think about clearing a bit. We can use the AND-EQUALS operation. ANDing a value with 1 will be equivalency, since if a 1 already exists
 * there a 1 will be in the output, and if a 0 exists there a 0 will exist in the output. Meanwhile ANDing something with a 0 will always result
 * in a 0, since anything AND 0 is false. This means to clear a certain bit, we want a 0 in that bit but 1's in all others to maintain equality
 * elsewhere. We have our BITx defines, which correspond to a 1 in the specified bit position, so how can we use a BITx define to clear a bit?
 * Invert all the bits in it! To take the OR example from above, it can be change to <code>val &= ~BIT7</code>. Since <code>val</code> was already
 * equal to 11101001 at the end of our OR operation, now we're ANDing it with 01111111. This will give us a final output of 01101001, where BIT7 is cleared.
 *
 * @see <a href="https://learn.sparkfun.com/tutorials/digital-logic">Sparkfun's Digital Logic intro</a>
 * @see <a href="http://www.cprogramming.com/tutorial/bitwise_operators.html">Bitwise Operations in C</a>
 * @see <a href="http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c">Set, Clear, and Toggle a Single Bit in C</a>
 *
 * @section REGISTERS Registers?
 * @see <a href="http://www.embedded.com/design/programming-languages-and-tools/4432746/Device-registers-in-C">Device Registers in C</a>
 */